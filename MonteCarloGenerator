"""
Monte Carlo Generator 0.5
for building time series with predictable cycles
Created on Thu Apr 4 21:18:30 2019

@author: Dylan
"""
from datetime import datetime as dt
from datetime import timedelta as td
from random import randint as rd
from random import random as rm
from random import sample as rs
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#########################################################################
#########################################################################
## Base Class
#########################################################################
#########################################################################
class MonteCarloCalendar():
    '''
    Builds an environment for a calendar generator.
    Imports datetime and calendar for use in the rest of the Class.
    '''
    def __init__(self, freq='H', start=dt.today(), end=dt.today()):
        '''
        freq: a pandas frequency string that is the lowest tick to be recorded in the data (e.g.
        you may generate on second ticks, but collate on hour tick granularity), in milliseconds.
        Defines the ticks for the cycle - the smallest time unit is used for building the calendar.
        start: a datetime object that is the start date for this calendar environment, defaults to
        datetime.today()
        end: a datetime object that is the end date for this calendar environment, defaults to
        datetime.today()
        '''

        # create the dataframe and make the index into a datetimeindex
        self.m_c_t_s = pd.DataFrame() #build our dataframe
        date_rng = pd.date_range(start=start, end=end, freq=freq) #create a datetime range
        self.m_c_t_s['datetime'] = pd.to_datetime(date_rng) #make it into a col of accurate # rows
        self.m_c_t_s = self.m_c_t_s.set_index('datetime') #set it to the index

    def engage(self, rolls=100, number_builds=100, filters=1, probability=0.1):
        '''
        Builds the generator. Creates the data for the dataframe.
        rolls: number of rolls to add per cycle - this will be randomised from 1 to rolls
        where rolls is user-defined. This is the number of "rolls" that will be added to
        each row of the dataframe per selection by randomised filter.
        filters: maximum number of filters to apply to each slice of the dataframe,
        e.g. dayofmonth, hour, selections applied =2 filters.
        probability: the probability that any one roll will "hit" - out of 1
        '''
        for dummy_i in range(number_builds):
            self.build_cycle(rolls, filters) #filters set to one for now
        self.standard_cycle(probability)

    @classmethod
    def interval_builder(cls, interval):
        '''
        The interval is the maximum number of periods in the selected range
        This function generates a list of random numbers within this range
        '''
        num_select = rd(1, interval) #select how many period selections will be made
        period_list = rs(range(interval), num_select)
        return period_list

    def build_cycle(self, rolls, filters):
        '''
        Apply the mathematical function to each datetimeindex selected by the mask
        '''
        #years don't work as per the rest of the items, must find fist year in index
        base_year = self.m_c_t_s.index
        base_year = base_year.year[0]
        
        #define the periods, used to generate frequencies
        timeperiods = {"Year" : self.m_c_t_s.index.year,
                       "Month" : self.m_c_t_s.index.month,
                       "Day" : self.m_c_t_s.index.day,
                       "Hour" : self.m_c_t_s.index.hour,
                       #self.m_c_t_s.index.minute,
                       #self.m_c_t_s.index.second,
                       "DayofYear" : self.m_c_t_s.index.dayofyear,
                       "WeekofYear" : self.m_c_t_s.index.weekofyear,
                       "DayofWeek" : self.m_c_t_s.index.dayofweek,
                       "Quarter" : self.m_c_t_s.index.quarter}

        roll = rd(1, rolls)
        filter_list = rs(timeperiods.keys(), rd(1, filters)) #apply a random number of filters to the index
        final_boolean = np.full((len(self.m_c_t_s),), True, dtype=bool)

        for i in filter_list:
            results = self.interval_builder(len(list(set(timeperiods[i]))))
            if i == "Year":#fix the year issue
                results = [s + year for s in results]
            boolean_filter = timeperiods[i].isin(results)
            final_boolean = np.logical_and(boolean_filter, final_boolean)
            if i not in list(self.m_c_t_s):
                self.m_c_t_s[i] = 0
        
        self.m_c_t_s.loc[self.m_c_t_s.index[final_boolean], filter_list[0]] += roll

    def standard_cycle(self, prob):
        '''
        Build a cycle based on standard periods
        '''
        columns = list(self.m_c_t_s)
        self.m_c_t_s["Total"] = self.m_c_t_s.sum(axis = 1) #exclude the Total column from the process below
        
        for i in columns:
            self.m_c_t_s[i + "_Results"] = self.m_c_t_s[i].apply(lambda x: self.result_roller(x, prob))
            self.m_c_t_s[i + "_Ideal"] = self.m_c_t_s[i] * prob

        all_results = [s for s in list(self.m_c_t_s) if "_Results" in s]
        all_ideal = [s for s in list(self.m_c_t_s) if "_Ideal" in s]
    
        self.m_c_t_s["Total_Results"] = self.m_c_t_s[all_results].sum(axis = 1)
        self.m_c_t_s["Total_Ideal"] = self.m_c_t_s[all_ideal].sum(axis = 1)

    @classmethod
    def result_roller(cls, rolls, prob):
        '''
        Takes each interval and rolls the proverbial dice to see if it fires for every occurrence
        '''
        result = 0
        for dummy_i in range(rolls):
            rand = rm()
            if rand <= prob:
                result += 1
        return result
    
    def result_plot(self):
        columns = list(self.m_c_t_s)
        all_results = [s for s in columns if "_Results" in s]
        all_ideal = [s for s in columns if "_Ideal" in s]
        result_df = self.m_c_t_s[all_results]
        ideal_df = self.m_c_t_s[all_ideal]
        result_df.plot.area()
        ideal_df.plot.area()
